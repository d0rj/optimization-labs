# MAX Memory

- `-Xmx512m`: Max memory: 455 MB

**Ответ**: Установлено значение для **максимального** размера памяти в куче, которое может быть выделено JVM. Во время работы не потребовалось использовать более

- `-Xmx512m -Xms512m`: Max memory: 491 MB

**Ответ**: Для максимального и минимального размера кучи установлено одно и то же значение, которое фактически ниже указанного, однако это можно соотнести с фактом, что одна из survivor областей (неактивная в текущей итерации сборки и потому всегда пустая) не учитывается при расчетах памяти. Такая схема необходима для  борьбы с фрагментацией данных при копировании из eden в survivor.

- `-Xmx512m -Xms512m -XX:+PrintGCDetails`
```
Max memory: 491 MBHeap
PSYoungGen      total 153088K, used 13159K [0x00000007b5580000, 0x00000007c0000000, 0x00000007c0000000)
eden space 131584K, 10% used [0x00000007b5580000,0x00000007b6259c00,0x00000007bd600000)
from space 21504K, 0% used [0x00000007beb00000,0x00000007beb00000,0x00000007c0000000)
to   space 21504K, 0% used [0x00000007bd600000,0x00000007bd600000,0x00000007beb00000)
ParOldGen       total 349696K, used 0K [0x00000007a0000000, 0x00000007b5580000, 0x00000007b5580000)
object space 349696K, 0% used [0x00000007a0000000,0x00000007a0000000,0x00000007b5580000)
Metaspace       used 3790K, capacity 4546K, committed 4864K, reserved 1056768K
class space    used 421K, capacity 430K, committed 512K, reserved 1048576K
```

**Ответ**: В приведенном отчете о работе garbage collector'а указано зарезервированное количество памяти для областей gc. max memory = young gen + par old gen. Но в то же время xms = eden + to + from + parOldGen. Это соотносится с предыдущим ответом: текущая пустая survivor область (именованная to) всегда будет пуста и заполнена ничем, не учитываться в памяти, но при жтом зарезервирована для процесса.

- `-Xms512m -Xmx512m -XX:SurvivorRatio=100`: Max memory: 510 MB

**Ответ**: установив значение SurvivorRatio для программы был изменен размер для young generation пространства. Таким образом, survivor области были уменьшены (в отчете также отсутствует to space, однако размер eden увеличился)

- `-Xmx512m -XX:+UseG1GC`: Max memory: 512 MB

**Ответ**: изменив gc в программе поменялась схема разметки памяти для сборщика, так как g1 сборщик выделяет 5 равнозначных областей памяти, каждая из которых учтена в памяти, потому результат отличается от предыдущих. Важно понимать, что это **максимальная** возможная, а не используемая память

# Phantom References

1) `-verbose:gc -Xmx24m -XX:NewSize=16m -XX:MaxTenuringThreshold=1 -XX:-UseAdaptiveSizePolicy`:

**Ответ**: Аргументами был задан малый максимальный объем кучи, большая доля которой отведена на новое поколение. Также была преднастроена малая задержка до попадания объектов в старое поколение. С учетом большого количества запросов на выделение памяти Minor GC вызывается достаточно часто, так как eden область быстро заполняется. Full GC не был вызван ни разу из-за наличия phantom-ссылок на один единственный объект в дополнение к постоянной очистке ссылок, что наводит на мысль о том, что до old gen на самом деле никто не доживает (это кажется более очевидным, учитывая, что в цикле создаются объекты, которые будут мертвы уже на следующей итерации, что не позволит им выйти из young gen)

2) `-Dphantom.refs=true -verbose:gc -Xmx24m -XX:NewSize=16m -XX:MaxTenuringThreshold=1 -XX:-UseAdaptiveSizePolicy`
 
**Ответ**: поскольку с текщими настройками все создаваемые во время цикла объекты, обернутые в фанотмные ссылки, помещаются в буфер, то они успевают доживать до old gen из-за чего наблюдаются более частые вызовы Full GC. Ссылки очищаются в конце цикла, потому память освобождается

3) `-Dphantom.refs=true -verbose:gc -Xmx64m -XX:NewSize=32m -XX:MaxTenuringThreshold=1 -XX:-UseAdaptiveSizePolicy`

**Ответ**: Задав аргументами увеличенный объем памяти young gen очищается быстрее, так как мертвые фантомные ссылки успевают очищаться до вызова gc. Full GC вызывается реже, так как меньшее количество мертвыз объектов попадает в old gen

4) `-Dphantom.refs=true -Dno.ref.clearing=true -verbose:gc -Xmx64m -XX:NewSize=32m -XX:MaxTenuringThreshold=1 -XX:-UseAdaptiveSizePolicy`

**Ответ**: Программа бросила OutOfMemoryError так как теперь очищение ссылок не происходит и они попадают в old gen. Young gen заполняется также быстро, однако теперь объекты не успевают очищаться и улетают в old gen из-за низкой задержки для попадания старое поколение

# Premature Promotion

1) `-verbose:gc -XX:MaxTenuringThreshold=1 -XX:-UseAdaptiveSizePolicy`

**Ответ**: JVM самостоятельно выбрала стартовый размер кучи. Из-за большого количества памяти для young gen и установленного малого времени продвижения на каждом (достаточно частом) вызове Minor GC созданные объекты очищаются, не успев долететь в old gen, вследствие чего вызова Full GC не происходит

2) `-verbose:gc -Xmx24m -XX:NewSize=16m -XX:MaxTenuringThreshold=1 -XX:-UseAdaptiveSizePolicy`

**Ответ**: Аргументами явно задан небольшой размер кучи с бОльшим по отношению к старому поколению новым поколением. Объекты быстро заполняют области памяти в молодом поколении, и при вызове Minor GC успевают попасть в old gen. Из-за меньшего по отношению к young gen объему памяти old gen быстро заполняется и во время работы программы наблюдаются частые вызовы Full GC. Такой результат объясняется малым размером old gen и быстрым переходом из young gen в old gen

3) `-Xlog:gc=debug:file=gc.txt -Xmx64m -XX:NewSize=32m -XX:MaxTenuringThreshold=1 -XX:-UseAdaptiveSizePolicy`

**Ответ**: Аргументами задан увеличенный максимальный объем кучи и более высокий объем young gen, что привело к меньшему количеству вызовов как Minor GC, так и Full GC. Однако вызовы все равно случаются, так как объекты так или иначе заполняют old gen, просто это происходит с куда меньшей интенсивностью.

4) `-Dmax.chunks=1000 -verbose:gc -Xmx24m -XX:NewSize=16m -XX:MaxTenuringThreshold=1 -XX:-UseAdaptiveSizePolicy`

**Ответ**: Уменьшение максимального количества элементов в коллекции приводит к более частому вызову операции clear над коллекцией, что способствует более частой очистке young gen вместо продвижения объектов в old gen. Так мы наблюдаем частые вызовы Minor GC и полное отсутствие вызова Full GC.

5) `-verbose:gc -Xmx64m -XX:NewSize=32m -XX:+NeverTenure -XX:-UseAdaptiveSizePolicy`

**Ответ**: Параметр NeverTenure не работает в java-8, при смене jdk на 11 версию не было ни единого вызова Full GC, так как параметр NeverTenure отключает продвижение объектов из young gen в old gen, потому наблюдаются только вызовы Minor GC

# Soft Refs

1) `-verbose:gc -Xmx24m -XX:NewSize=16m -XX:MaxTenuringThreshold=1 -XX:-UseAdaptiveSizePolicy`

**Ответ**: Многократные выделения памяти при малом объеме кучи порождают частые вызовы Minor GC. Мягкие ссылки отключены, потому объекты порождаемые в цикле быстро умирают, не доживая до old gen. Вызовы Full GC наблюдаются, однако в крайне малом количестве, это можно объяснить небольшими темпами заполнения old gen, да и к тому же все объекты, доживающие до old gen являются мягкими ссылками, которые имеют свойство очищаться при недостатке памяти

2) `-Dsoft.refs=true -verbose:gc -Xmx24m -XX:NewSize=16m -XX:MaxTenuringThreshold=1 -XX:-UseAdaptiveSizePolicy`

**Ответ**: При включении мягких ссылок для всех объектов большее количество объектов доживает до old gen, и в каждый Full GC происходит очистка мягких ссылок для высвобождения памяти

3) `-Dsoft.refs=true -verbose:gc -Xmx64m -XX:NewSize=32m -XX:MaxTenuringThreshold=1 -XX:-UseAdaptiveSizePolicy`

**Ответ**: Увеличенный размер кучи снижает частоту вызовов GC, вследствие чего old gen заполняется медленнее и вызовы Full GC происходят реже. Однако, при необходимости, soft-ссылки удаляются сборщиком во избежание OutOfMemoryError

# Weak Refs

1) `-verbose:gc -Xmx24m -XX:NewSize=16m -XX:MaxTenuringThreshold=1 -XX:-UseAdaptiveSizePolicy`

**Ответ**: Малый размер кучи, быстрый переход объектов в old gen. Основной набор объектов в цикле не сохраняется, однако из-за частых выделений памяти и небольшого объема кучи, некоторые из них попадают в old gen, из-за чего наблюдаются сравнительно редкие вызовы Full GC сравнительно редки (малая интенсивность заполнения old gen)

2) `-Dweak.refs=true -verbose:gc -Xmx24m -XX:NewSize=16m -XX:MaxTenuringThreshold=1 -XX:-UseAdaptiveSizePolicy`

**Ответ**: Включение weak-ссылок для всех объектов означает, что практически все объекты будут очищены gc во время ближайшей Minor GC сборки, если больше не нужны. Частота GC может оставаться высокой из-за постоянных выделений памяти при небольшом ее объеме, но Full GC сравнительно редки (реже, чем в 1 случае), так как слабые ссылки не задерживают объекты в памяти

3) `-Dweak.refs=true -verbose:gc -Xmx64m -XX:NewSize=32m -XX:MaxTenuringThreshold=1 -XX:-UseAdaptiveSizePolicy`

**Ответ**: Из-за увеличенного объема кучи и наличия слабых ссылок объекты не доживают до Full GC, так как не успевают попасть в old gen. Вызовов Full GC не наблюдается, из чего следует, что все объекты очищаются во время Minor GC.
